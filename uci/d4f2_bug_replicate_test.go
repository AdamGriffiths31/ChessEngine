package uci

import (
	"os"
	"strings"
	"testing"
)

// TestReplicateD4F2Search tests the actual AI search that produced the d4f2 illegal move
// This test replicates the exact conditions from the PGN game and calls the search
// to see if our AI still tries to select the illegal d4f2 move.
func TestReplicateD4F2Search(t *testing.T) {
	engine := NewUCIEngine()
	// Set output to avoid nil pointer dereference
	engine.output = os.Stdout
	
	// Initialize the engine
	engine.HandleCommand("uci")
	engine.HandleCommand("ucinewgame")
	
	t.Logf("=== REPLICATING THE EXACT D4F2 BUG ===")
	
	// Apply the exact game moves from the PGN that led to the d4f2 bug
	// 1. d4 d5 2. a3 e6 3. b3 Qf6 4. c3 Qd8 5. e3 b6 6. f3 Be7 7. g3 c5 
	// 8. h3 Bb7 9. a4 Nf6 10. b4 Bd6 11. c4 cxb4 12. e4 Bxg3+
	moveSequence := "d2d4 d7d5 a2a3 e7e6 b2b3 d8f6 c2c3 f6d8 e2e3 b7b6 f2f3 f8e7 g2g3 c7c5 h2h3 c8b7 a3a4 g8f6 b3b4 e7d6 c3c4 c5b4 e3e4 d6g3"
	
	positionCmd := "position startpos moves " + moveSequence
	t.Logf("Applying position: %s", positionCmd)
	
	response := engine.HandleCommand(positionCmd)
	if response != "" {
		t.Logf("Position response: %s", response)
	}
	
	// Verify the critical position after Bxg3+
	currentFEN := engine.engine.GetCurrentFEN()
	t.Logf("Position after Bxg3+: %s", currentFEN)
	
	// Verify White is in check with only 2 legal moves
	legalMoves := engine.engine.GetLegalMoves()
	t.Logf("White has %d legal moves:", legalMoves.Count)
	
	for i := 0; i < legalMoves.Count; i++ {
		move := legalMoves.Moves[i]
		moveStr := move.From.String() + move.To.String()
		t.Logf("  Legal[%d]: %s (Piece=%c)", i, moveStr, move.Piece)
	}
	
	// Confirm d4f2 is NOT in legal moves (this should pass)
	d4f2Found := false
	for i := 0; i < legalMoves.Count; i++ {
		move := legalMoves.Moves[i]
		moveStr := move.From.String() + move.To.String()
		if moveStr == "d4f2" {
			d4f2Found = true
			break
		}
	}
	
	if d4f2Found {
		t.Errorf("‚ùå CRITICAL: d4f2 found in legal moves - move generator bug!")
	} else {
		t.Logf("‚úÖ Confirmed: d4f2 correctly NOT in legal moves")
	}
	
	t.Logf("\n=== TRIGGERING AI SEARCH (WHERE BUG OCCURS) ===")
	
	// Now trigger the search that caused the d4f2 bug
	// Use a short time control to avoid long waits
	searchCmd := "go movetime 1000"  // 1 second search
	t.Logf("Starting search: %s", searchCmd)
	
	// Capture the response which should contain "bestmove"
	searchResponse := engine.HandleCommand(searchCmd)
	t.Logf("Search response: %s", searchResponse)
	
	// Parse the bestmove from response
	lines := strings.Split(searchResponse, "\n")
	var bestMove string
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "bestmove ") {
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				bestMove = parts[1]
			}
			break
		}
	}
	
	t.Logf("AI selected move: '%s'", bestMove)
	
	// THIS IS THE CRITICAL TEST: Did our AI try to select d4f2?
	if bestMove == "d4f2" {
		t.Errorf("‚ùå BUG REPLICATED: AI selected illegal move d4f2!")
		t.Errorf("   This is the exact bug that caused cutechess-cli to reject our move")
		t.Errorf("   The AI search is somehow selecting a move not in the legal moves list")
	} else if bestMove == "e1d2" || bestMove == "e1e2" {
		t.Logf("‚úÖ AI correctly selected legal king move: %s", bestMove)
	} else if bestMove == "(none)" || bestMove == "" {
		t.Logf("‚ö†Ô∏è  AI returned no move - this might indicate a search problem")
	} else {
		t.Errorf("‚ùå AI selected unexpected move: %s", bestMove)
		t.Errorf("   Expected e1d2 or e1e2 (the only legal moves)")
	}
	
	t.Logf("\n=== ANALYSIS COMPLETE ===")
	
	if bestMove == "d4f2" {
		t.Logf("üêõ BUG CONFIRMED: The AI search algorithm has a bug that causes it to")
		t.Logf("   select moves that are not in the legal moves list generated by the move generator.")
		t.Logf("   This explains why cutechess-cli rejected our move as illegal.")
	} else {
		t.Logf("‚úÖ Bug may be fixed: AI did not select the illegal d4f2 move")
		t.Logf("   The original issue might have been resolved in recent changes")
	}
}

// TestCheckSearchAlgorithmIntegrity tests if search can select illegal moves
func TestCheckSearchAlgorithmIntegrity(t *testing.T) {
	engine := NewUCIEngine()
	// Set output to avoid nil pointer dereference
	engine.output = os.Stdout
	engine.HandleCommand("uci")
	engine.HandleCommand("ucinewgame")
	
	// Set up the critical position directly via FEN
	criticalFEN := "rn1qk2r/pb3ppp/1p2pn2/3p4/PpPPP3/5PbP/8/RNBQKBNR w KQkq - 0 13"
	
	t.Logf("Testing search integrity with critical position...")
	t.Logf("FEN: %s", criticalFEN)
	
	// Apply the position
	fenCmd := "position fen " + criticalFEN
	engine.HandleCommand(fenCmd)
	
	// Verify position
	currentFEN := engine.engine.GetCurrentFEN()
	if currentFEN != criticalFEN {
		t.Errorf("FEN mismatch: expected %s, got %s", criticalFEN, currentFEN)
	}
	
	// Get legal moves
	legalMoves := engine.engine.GetLegalMoves()
	t.Logf("Legal moves from this position: %d", legalMoves.Count)
	
	legalMoveStrings := make([]string, 0, legalMoves.Count)
	for i := 0; i < legalMoves.Count; i++ {
		move := legalMoves.Moves[i]
		moveStr := move.From.String() + move.To.String()
		legalMoveStrings = append(legalMoveStrings, moveStr)
		t.Logf("  %s", moveStr)
	}
	
	// Search for best move
	searchResponse := engine.HandleCommand("go depth 3")
	
	// Extract bestmove
	lines := strings.Split(searchResponse, "\n")
	var selectedMove string
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "bestmove ") {
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				selectedMove = parts[1]
			}
			break
		}
	}
	
	t.Logf("Search selected: %s", selectedMove)
	
	// Verify selected move is in legal moves
	found := false
	for _, legal := range legalMoveStrings {
		if legal == selectedMove {
			found = true
			break
		}
	}
	
	if !found && selectedMove != "" && selectedMove != "(none)" {
		t.Errorf("‚ùå SEARCH INTEGRITY VIOLATION: Selected move '%s' is not in legal moves!", selectedMove)
		t.Errorf("   Legal moves were: %v", legalMoveStrings)
	} else {
		t.Logf("‚úÖ Search integrity OK: Selected move is legal")
	}
}