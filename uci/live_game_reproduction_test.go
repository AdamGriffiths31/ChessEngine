package uci

import (
	"testing"
	"strings"
	"time"
)

// TestLiveGameReproduction runs the exact scenario that causes illegal move
func TestLiveGameReproduction(t *testing.T) {
	t.Logf("=== LIVE GAME REPRODUCTION TEST ===")
	
	// Create UCI engine with enhanced logging
	engine := NewUCIEngine()
	
	// Run the exact sequence that leads to the illegal move
	commands := []string{
		"uci",
		"isready", 
		"position fen rn1qk2r/1b3ppp/1p2pn2/p2p4/PpPQPb2/5P1P/3K4/RNBQ1BNR w kq - 1 14",
		"go depth 1",
	}
	
	t.Logf("Executing command sequence:")
	for i, cmd := range commands {
		t.Logf("  %d: %s", i+1, cmd)
		response := engine.HandleCommand(cmd)
		
		// Log the response
		if response != "" {
			t.Logf("     -> %s", response)
		} else {
			t.Logf("     -> (no immediate response)")
		}
		
		// For go command, give it time to process
		if strings.HasPrefix(cmd, "go") {
			time.Sleep(100 * time.Millisecond)
		}
	}
	
	t.Logf("\n=== ANALYSIS ===")
	t.Logf("Check the communication logs for:")
	t.Logf("1. Exact position loaded")
	t.Logf("2. Move generated by AI")
	t.Logf("3. Whether d4e3 is returned as bestmove")
	
	// The logs will be in /tmp/uci_communication_*.log
	t.Logf("\nLogs available at: /tmp/uci_communication_*.log")
	t.Logf("UCI debug logs at: /tmp/uci_debug_*.log")
}

// TestPositionSequenceToIllegalMove tests the complete game sequence that leads to the illegal position
func TestPositionSequenceToIllegalMove(t *testing.T) {
	t.Logf("=== POSITION SEQUENCE TEST ===")
	
	// Create UCI engine
	engine := NewUCIEngine()
	
	// Initialize
	t.Logf("1. Initializing engine...")
	engine.HandleCommand("uci")
	engine.HandleCommand("isready")
	
	// Start from initial position and play moves leading to the illegal position
	t.Logf("2. Setting starting position...")
	engine.HandleCommand("position startpos")
	
	// Play a sequence of moves that could lead to the problematic position
	// (This is a hypothetical sequence - we'd need the actual game moves)
	moves := []string{
		"e2e4", "e7e5",    // 1. e4 e5
		"g1f3", "b8c6",    // 2. Nf3 Nc6  
		"f1c4", "f8c5",    // 3. Bc4 Bc5
		"d2d3", "d7d6",    // 4. d3 d6
		"c1g5", "c8g4",    // 5. Bg5 Bg4
		"h2h3", "g4h5",    // 6. h3 Bh5
		"b1c3", "g8f6",    // 7. Nc3 Nf6
		"a2a4", "a7a5",    // 8. a4 a5
	}
	
	// Apply moves one by one
	for i := 0; i < len(moves); i += 2 {
		moveNum := (i/2) + 1
		whiteMove := moves[i]
		blackMove := ""
		if i+1 < len(moves) {
			blackMove = moves[i+1]
		}
		
		if blackMove != "" {
			moveStr := strings.Join(moves[:i+2], " ")
			cmd := "position startpos moves " + moveStr
			t.Logf("  Move %d: %s %s", moveNum, whiteMove, blackMove)
			
			response := engine.HandleCommand(cmd)
			if response != "" {
				t.Logf("    Response: %s", response)
			}
		}
	}
	
	// Get current position
	t.Logf("3. Getting current FEN position...")
	// We'd need to add a command to get FEN, or check the logs
	
	// Now test a few moves to see if any generate illegal moves
	t.Logf("4. Testing move generation...")
	for depth := 1; depth <= 3; depth++ {
		t.Logf("  Testing depth %d...", depth)
		response := engine.HandleCommand("go depth " + string(rune('0'+depth)))
		if response != "" && strings.Contains(response, "bestmove") {
			move := extractMoveFromResponse(response)
			t.Logf("    Depth %d bestmove: %s", depth, move)
			
			// Check if this could be a problematic move
			if move == "d4e3" || move == "f6f7" {
				t.Logf("    *** FOUND PROBLEMATIC MOVE: %s ***", move)
			}
		}
	}
}

// extractMoveFromResponse extracts the move from a "bestmove" response
func extractMoveFromResponse(response string) string {
	parts := strings.Fields(response)
	for i, part := range parts {
		if part == "bestmove" && i+1 < len(parts) {
			return parts[i+1]
		}
	}
	return ""
}